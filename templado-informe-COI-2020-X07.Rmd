---
title: Análisis bioinformático de la diversidad de zooplancton en la zona epipelágica
  del Golfo de México usando el marcador COI
author: "Grupo Bioinformática"
date: "Informe `r format(Sys.Date())`"
output:
  word_document:
  # word_document: default
  # pdf_document: default
#    reference_docx: templado-informe-Jan2019.docx
---

```{r setup, include=FALSE}
# Setting global option in all the chunks-code
knitr::opts_chunk$set(warning=FALSE, echo = FALSE, message = FALSE, dpi=300,
                      #fig.path='~/metagenomics/COI/run014/figures',
                      fig.width=12, fig.height=8 
                      )

## Clean workspace
rm(list=ls()); 

```

## Generalidades del análisis

```{r paths}
set <- 'X07'
path <- "~/metagenomics/MG_COI/run018/"

qc.dir <- paste0(path, "/fastqc")
qc.files <- list.files(qc.dir, full.names = TRUE, pattern = set)

track.dir <- paste0(path)

nsamp <- as.numeric(length(qc.files)/2) # for paired-end

run <- 'run018'

fasta.dir <- track.dir

url <- 'https://raw.githubusercontent.com/RJEGR/metagenomics/master/readtx.R'

source(url)

Ranks <- c("Dominio","Reino", "Filo", "Clase", "Orden", "Familia", "Genero", "Especie")

```

```{r inputs name}

ctb.file = "run018_test01_ASVs_count.table"
tax.file = "run018_test01_ASVs.ALL.wang.taxonomy"
fasta.file = "run018_test01_ASVs.fasta"

```

```{r read.obj, echo = FALSE}
# Path files for processing within phyloseq
ctb.obj <- list.files(path, pattern = ctb.file, full.names = TRUE)
seqtab.nochim <- read.table(ctb.obj)


# Taxonomy is processed this time with cigom_coi_detected2worms.R script
tax.dir <- paste0(path, "/")
tax.file <- list.files(tax.dir, pattern = tax.file, full.names = TRUE)
tax <- read_rdp(tax.file, header = FALSE)

tax <- tax[-1] # remove root
names(tax) <- Ranks
```

```{r metadata, echo = FALSE}

#metadata <- dir(track.dir, pattern = "metadata.csv")
#samples <- read.table(metadata, sep='\t', header=TRUE)
 
samples.out <- colnames(seqtab.nochim)
cruice <- sapply(strsplit(samples.out, "\\."), `[`, 1)
subject <- sapply(strsplit(samples.out, "\\."), `[`, 2)
transect <- substr(subject,1,1)
type <- sapply(strsplit(samples.out, "\\."), `[`, 3)
samples <- data.frame(Crucero=cruice, Estación=subject, Transecto=transect, Tipo=type)
rownames(samples) <- samples.out

```

```{r phyloseq.obj, echo = FALSE}
# # #
# We now construct a phyloseq object directly from the dada2 outputs.
# # #
library(phyloseq)

#identical(names(seqtab.nochim),rownames(samples))
#identical(rownames(seqtab.nochim), rownames(tax))

phyloseq = phyloseq(otu_table(seqtab.nochim, taxa_are_rows = TRUE), 
                    tax_table(as(tax, 'matrix')), 
                    sample_data(samples))


```

```{r clean.obj}
# preprocessing count-matrix

physeq <- subset_samples(phyloseq, Crucero == set) # Subset_samples by cruice
physeq <- prune_taxa(taxa_sums(physeq) > 0, physeq) # # Removing any taxa of abundance of zero

keepTaxa = apply(X = as(otu_table(physeq), "matrix") > 0, # Removing any abundance of zero
                 MARGIN = 1, FUN = sum) > 2 # Remove ASVs not k greater than k (2L) 

# table(keepTaxa)

clean.obj = prune_taxa(keepTaxa, physeq)
```

Los datos provienen de muestras obtenidas en `r nsamp` estaciones que cubrió el crucero exploratorio `r set`. Para cada muestra se generaron amplicones COI. Los amplicones fueron secuenciados desde ambos extremos generando secuencias con una longitud de 300 pares de bases (pb) cada uno, en un secuenciador MiSeq de Illumina (del CICESE-CIGOM). Los siguientes resultados corresponden al análisis bioinformático de las secuencias generadas.

El análisis metagenómico se llevó a cabo en el cluster de cómputo OMICA-CICESE mediante el programa DADA2 versión 1.8. La tubería del análisis fue adaptada de la sugerida por Benjamin Callahan et. al. (2016).

El resumen del análisis se divide en tres etapas principales: 

1. Pre-procesamiento y alineamiento de secuencias.
2. Clasificación taxonómica y abundancia relativa.
3. Estimación de los índices de diversidad y presentación gráfica de resultados.
4. Cribado de Peces (_Actinoperigy_)

## Indice de figuras

* Figura 1. Promedio del puntaje de calidad Phred a lo largo de las lecturas de las bibliotecas. Bibliotecas Forward (F) y Reverse (R)
* Figura 2. Promedio del puntaje de calidad Phred por posición de nucleótido a lo largo de las lectura. Bibliotecas Forward (F) y Reverse (R)
* Figura 3. Número de secuencias a lo largo del procesamiento
* Figura 4. Panel del tamaño del empalme y amplicon
* Figura 5. Presencia de taxones en el crucero `r set` con varianza mayor a  1e-5, el filo Artropoda es removido.
* Figura 6. Composición de la comunidad a nivel Filo (heatmap). Se presentan los taxones con varianza mayor a  1e-5
* Figura 7. Composición de la comunidad a nivel Clase (heatmap). Se presentan los taxones con varianza mayor a  1e-5
* Figura 8. Composición de la comunidad a nivel Orden (heatmap). Se presentan los taxones con varianza mayor a  1e-5
* Figura 9.  Composición de las comunidades a nivel Familia a lo largo de las estaciones. Se presentan los taxones con varianza mayor a  1e-5; respectivamente, se indican el nivel de Filos y Clase en las columnas del panel derecho
* Figura 10. Géneros más abundantes a lo largo de todas las estaciones. Se muestran aquellos taxones que representan al menos 10% de la abundancia total por muestra.
* Figura 11. Curva de rarefacción por muestra. Se presenta el número de ASVs a lo largo de las estaciones en relación al número de secuencias.
* Figura 12. Diversidad alfa por estación. Se muestran los índices de diversidad alfa de Shannon e Inverso de Simpson calculados para la comunidad de zooplancton cada estación.
* Figura 13. PCoA. Componentes principales (Distancias Jaccard).

## Pre-procesamiento y alineamiento de secuencias.
El pre-procesamiento incluye el escrutinio de lecturas que no cumplen con los parámetros:

Respectivamente, los tamaños 170 y 230 bases de longitud como el valor mínimo para recortar las lecturas de _Forward_ (F) y _Reverse_ (R). El puntaje de calidad Phred mayor o igual a 15 en promedio. Un umbral de filtrado de calidad para eliminar lecturas con 2 bases erróneamente asignadas en ambas direcciones de las lecturas (F y R). Además, se descartan las lecturas empalmadas que tengan un tamaño menor a 120 bases de longitud y se elimina cualquier lectura que tenga identidad con el genoma del bacteriofago PhiX.

En la Figura 1 y 2 se muestra la distribución y el promedio de la calidad de los nucleótidos, respectivamente, en relación a su posición en la lectura. En este gráfico se observa una buena calidad (≥ 15) por posición a lo largo de toda la lectura. Las lecturas R son significativamente de menor calidad, especialmente al final de la lectura, lo cual es común en secuenciaciones con equipo Illumina.

```{r Figura 1 Calidad 1, fig.align = "center", fig.cap = "Figura 1. Promedio del puntaje de calidad Phred a lo largo de las lecturas de las bibliotecas. Bibliotecas Forward (F) y Reverse (R)."}

library("fastqcr")
library("ggplot2")
# First processes the quality screening by: fastqc *.fastq.gz -o fastqc/
#qc.dir <- c("/Users/cigom/metagenomics/example_samples/fastqc")
# qc.dir <- c("/Users/cigom/metagenomics/phyloseq_in/fastqc/")
# qc.files <- list.files(qc.dir, full.names = TRUE)

sample_names <- strsplit(dir(qc.dir, pattern = set), "_")
sample_names <- sapply(sample_names, "[", c(1,4))
sample_names <- as.data.frame(t(sample_names))
colnames(sample_names) <- c("Id","End")

sample_names$End <- as.character(sample_names$End)
sample_names$End[sample_names$End == "R1"] <- "F"
sample_names$End[sample_names$End == "R2"] <- "R"

qc <- qc_read_collection(qc.files, sample_names = sample_names$End, modules = c("Per sequence quality scores", "Per base sequence quality"))

qc_plot_collection(qc, modules = "Per sequence quality scores") +   theme_classic() + geom_line(size=1) + theme(plot.title = element_blank(), plot.subtitle = element_blank()) + ylab("Secuencias") + xlab("Calidad media de secuencia (Puntaje Phred)") + labs(color = "Biblioteca")

```

```{r Figura 2 Calidad 2, fig.align = "center", fig.cap = "Figura 2. Promedio del puntaje de calidad Phred por posición de nucleótido a lo largo de las lectura. Bibliotecas Forward (F) y Reverse (R)."}

qc_plot_collection(qc, modules = "Per base sequence quality") + geom_line(size=10) + theme_classic() + theme(plot.title = element_blank(), plot.subtitle = element_blank()) + ylab("Mediana de las puntuaciones de calidad") + xlab("Posición (pb)") + labs(color = "Biblioteca")

```


La Figura 3 muestra un resumen de la cantidad de secuencias por muestra a través de las diferentes etapas del procesamiento de las lecturas. Se denomina 'amplicon' a las secuencias resultantes. Cada amplicon representa una secuencia biológica.

El algoritmo de DADA2 reemplaza la selección de unidades operacionales taxonómicas (agrupamiento de similitud de secuencias) por variantes de las secuencias de amplicones (ASV, por su siglas en inglés). La Figura 3 muestra un resumen de las lecturas por muestra a través de las diferentes etapas del flujo de trabajo. Se denomina amplicón ( _ASVs_) a las secuencias empalmadas (no quimericas) que representan una secuencia con variación biológica. Un total de `r ntaxa(physeq)` amplicones fueron obtenidos para el crucero `r set`. Se consideró el tamaño del empalme como una variable de astringencia durante la generación de amplicones. La figura 4 muestra dos distribuciones, del tamaño del empalme y tamaño del amplicón (ASV) generado.

```{r Figura 3 tracking, echo = FALSE, fig.align = "center", fig.cap = "Figura 3. El número de lecturas totales, secuencias filtradas, secuencias empalmadas  y secuencias retenidas (quimeras removidas) a lo largo del procesamiento.", out.width='\\textwidth'}

track.file <- list.files(track.dir, pattern = "*track.tsv", full.names = TRUE)

track_out <- read.table(track.file, header = TRUE, stringsAsFactors = FALSE)
track_out <- track_out[c(grep(set, track_out$Sample)),] # Subset to the Cruise

id = as.character(track_out$Sample)
Station <- sapply(strsplit(id, "-"), '[', 2)
track_out$Sample <- Station

track_m <- reshape2::melt(track_out, id.vars="Sample", 
                          variable.name = "Process", 
                          value.name = "Reads")


track_m$Process <- factor(track_m$Process, 
                          levels = c("input", "filtered", 
                                     "denoisedF", "denoisedR", 
                                     "merged", "tabled", "nonchim"),
                          ordered=T)

# order levels

levels <- track_out[order(track_out$input, decreasing = TRUE), 'Sample']
track_m$Sample <- factor(track_m$Sample, levels = levels)

#
track_plot <- ggplot(track_m, aes(x=Sample, y=Reads, fill=Process)) + 
    geom_col(position = position_identity(), width = 0.8, aes(fill = Process), alpha = 0.7) +
    scale_fill_brewer(palette = "BrBG", direction = 1) +
    labs(x="Muestras", y = "Lecturas") + # title=paste0(run, ". Corte de lecturas a lo largo del procesamiento"),
    theme_minimal() +
    theme(axis.text.x = element_text(angle = 45, hjust=1, size = 7), axis.text.y = element_text(size = 7)) +
    coord_flip() + geom_hline(yintercept = min(track_m[,'Reads']), linetype = "dashed", alpha = 0.9) 



print(track_plot)

png(paste0(path,"/", "track_plot.png"), units="px", width=2400, height=2600, res=400)
plot(track_plot, col=adjustcolor("black", alpha=0.2))
dev.off()
```

```{r Figura 4 (remplazo), out.width='\\textwidth', eval = FALSE, echo = FALSE}

library(GGally)

mergedf.dir <- paste0(path")
mergedf.file <- list.files(track.dir, pattern = "*_mergedf.tsv", full.names = TRUE)
merge_df <- read.table(mergedf.file, header = TRUE, stringsAsFactors = FALSE)

# Adding factor to color the plot by metadata info!
samples.fc <- merge_df$Sample
subject <- sapply(strsplit(samples.fc , "-"), `[`, 2)
samples.fc <- data.frame(Crucero=sapply(strsplit(samples.fc , "-"), `[`, 1), 
                         Estación=subject, 
                         Transecto=substr(subject,1,1), 
                         Tipo=sapply(strsplit(samples.fc , "-"), `[`, 3))

merge_df <- cbind(samples.fc, merge_df)
merge_df <- merge_df[c(grep(set, merge_df$Crucero)),] # Subset to the Cruise


# my_bin <- function(data, mapping, ..., low = "#132B43", high = "#56B1F7") {
#   ggplot(data = data, mapping = mapping) +
#     geom_bin2d(...) +
#     scale_fill_gradient(low = low, high = high)
# }

pm <- ggpairs(
  merge_df, columns = c("nmatch", "seqlen"),
            columnLabels = c("Región del empalme (nt)", "Tamaño del ASV (nt)"),
  mapping = aes(color = Tipo, alpha = 0.7), 
  upper = list(continuous = "blank"),
  lower = list(
    continuous = my_bin
  )
) + theme_bw()

pm

```

```{r Figura 4 empalme, echo = FALSE, fig.align = "center", fig.cap = "Figura 4. Metricas de calidad del analisis general de los amplicones. Tamano del empalme y amplicón generado. Una correlación negativa es señalada.", out.width='\\textwidth', fig.height=8, fig.width=8 }

mergedf.dir <- track.dir
mergedf.file <- list.files(track.dir, pattern = "*_mergedf.tsv", full.names = TRUE)
merge_df <- read.table(mergedf.file, header = TRUE, stringsAsFactors = FALSE)

# Adding factor to color the plot by metadata info!

samples.fc <- merge_df$Sample

subject <- sapply(strsplit(samples.fc , "-"), `[`, 2)

samples.fc <- data.frame(Crucero=sapply(strsplit(samples.fc , "-"), `[`, 1), 
                         Estación=subject, 
                         Transecto=substr(subject,1,1), 
                         Tipo=sapply(strsplit(samples.fc , "-"), `[`, 3))

merge_df <- cbind(samples.fc, merge_df)
merge_df <- merge_df[c(grep(set, merge_df$Crucero)),] # Subset to the Cruise

data <- data.frame(x = merge_df[,'nmatch'], y = merge_df[,'seqlen'])

# placeholder plot - prints nothing at all
empty <- ggplot() + geom_point(aes(1, 1), colour = "white") + 
  theme(plot.background = element_blank(),
        panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
        panel.border = element_blank(), 
        panel.background = element_blank(),
        axis.title.x = element_blank(),
        axis.title.y = element_blank(), 
        axis.text.x = element_blank(), 
        axis.text.y = element_blank(),
        axis.ticks = element_blank())

#Assign color variables
col1 = "#d8e1cf" 
col2 = "#438484"

# Density of x and y variables

p1 <- ggplot(data = data, aes(x=x,y=y)) +
    geom_bin2d(bins = 100) +
    scale_fill_gradient(low = col1, high = col2) +
    theme(legend.position = "none",
        panel.grid = element_blank(),
        axis.title = element_blank(),
        axis.text = element_blank(),
        panel.background = element_blank(),
        line = element_blank())+
        coord_cartesian(xlim = c(min(data$x), max(data$x)), 
                        ylim = c(min(data$y), max(data$y)))




p2 <- ggplot(data, aes(x = x)) + 
      stat_density(fill = col1) + 
      geom_rug(col = col1, alpha = 0.1) + 
      theme(panel.background = element_blank(),
            line = element_blank(),
            axis.title.y=element_blank()) + 
      xlab("Región del empalme (nt)") + scale_y_continuous(breaks = c(0, 1))
      # coord_cartesian(xlim = c(min(data$x), max(data$x)))


p3 <- ggplot(data, aes(x = y)) + 
      stat_density(fill = col2) + 
      geom_rug(col = col2, alpha = 0.1)  + 
      coord_flip(xlim = c(min(data$y), max(data$y))) +
      scale_y_continuous(breaks = c(0, 1)) +
      theme(panel.background = element_blank(),
            line = element_blank(),
            axis.title.x=element_blank()) + 
      xlab("Tamaño del amplicón (nt)")

# arrange the plots together, with appropriate height and width for each row
# and column

library(gridExtra)

grid.arrange(p2, empty, p1, p3,
                 ncol=2, 
                 nrow=2, 
                 widths=c(4, 1), 
                 heights=c(1, 4))

```

```{r remove.na(testing), eval=F}
#ntaxa(subset_taxa(phyloseq, Reino=="Undetermined"))
# physeq = subset_taxa(physeq, Reino!="Undetermined")

#ntaxa(subset_taxa(clean.obj, Reino=="Undetermined"))
clean.obj = subset_taxa(clean.obj, Especie!="NA")

table(tax_table(physeq)[,2])
table(tax_table(phyloseq)[,2])
table(tax_table(clean.obj)[,2])

```

```{r write.table, eval=F}
save <- psmelt(clean.obj)
# save <- psmelt(physeq)
colnames(save)[1] <- "ASV"
write.csv(save, file = paste0(path, "/", set, "_taxones_identificados.csv"), 
          row.names = FALSE, quote = FALSE)
rm(save)
```

```{r remove non-animalia and sporious features}
# Removing any abundance of zero and
# Remove taxa not k greater than k (2L) 

physeq <- subset_taxa(physeq, Reino == "Animals")
physeq <- prune_taxa(taxa_sums(physeq) > 0, physeq)

# system(paste0('ls ', path, '*count_table'))

write.table(otu_table(physeq), paste0(path, 'run018_test01_ASVs_animalia_feature_count.table'))

# Rscript --vanilla estimate_richness.R *_animalia_feature_count.table

```


```{r transform.sample.counts}
# Transform dataset to relative abundance
physeq2 <- NULL
# usar clean.obj o quitar zeros de physeq:
#physeq2 <- clean.obj
physeq2 <- transform_sample_counts(physeq, function(x) (x / sum (x) ) )
# physeq2 <- phyloseq::filter_taxa(physeq2, function(x) var(x) > 1e-5, TRUE)
physeq2 <- transform_sample_counts(physeq2, function(x) x * 100 )

```

Debido a que el número de secuencias para cada muestra individual fue diferente. Con el objetivo de comparar las diferencias entre las muestras, se estandarizó la matriz de distribución de taxones (eg. OTUs) en abundancia relativa (RA) basada en la siguiente ecuación: $$RA_{ij} = \frac{S_{ij}}{\sum_{j=1}^{n} S_{ij}}*100$$

Donde $i$ es la posición de la muestra (1 a $m$), $j$ es la posición del taxon (1 a $n$) y  $S_{ij}$ es el número de secuencias en la muestra i y el taxón de la posición $j$. $\sum_{j=1}^{n} S_{ij}$ equivale a la sumatoria de las secuencias en la muestra $i$. Aquí m equivale a `r nsamples(physeq)` muestras y $n$ equivale a `r ntaxa(physeq)` taxones.

## Clasificación taxonómica y abundancia relativa

Para la etapa de asignación implementamos la base de datos BOLD. Los amplicones se asignaron utilizando el clasificador bayesiano RDP (wang et. al 2007). El algoritmo de asignación fue configurado con los siguientes parámetros, bootstrap de confidencia = 99, iteraciones = 1000 y tamaño de k-mero = 8 (debido a que cada amplicón representa una variable biológica (amplicones libre de error) se usó un bootstrap de 99 para obtener una asignación astringente. Finalmente,  se llevó a cabo la conversión de las asignaciones obtenidas con la base de referencia midori con la taxonomía de worms (world register of marine species) usando un script casero.

La figura 5 muestra el árbol de los taxones presentes en el crucero `r set`. Se observan taxones que estuvieron presentes más de dos veces en las muestras del crucero. La paleta de colores nos indican los taxones que predominan a lo largo de las muestras siendo el color gris los menos prevalentes. La tabla adjunta (`r paste0(set, "_taxones_identificados.csv")`) contiene información desglosada que se presenta en esta figura.

Para obtener una perspectiva biológica de la las comunidades se calculó la abundancia de los amplicones colapsados a diferentes niveles taxonómicos. El siguiente grupo de figuras (Figuras 6 a 9) muestra en mapas de calor la abundancia aglomerada de los taxones por estación a lo largo de los niveles taxonómicos Filo, Clase, Orden y Familia.  Además, la figura 10 se observan los géneros abundantes a lo largo de las muestras. Se conservaron aquellos con una varianza mayor a 1e-5, corresponde un número de `r ntaxa(clean.obj)` taxones a lo largo de las muestras del crucero `r set`

```{r Figura n. midori2worms}

```

```{r Figura 5. metacoder, fig.align = "center", fig.cap = "Figura 5. Presencia de taxones en el crucero. taxones con varianza mayor a  1e-5, el filo Artropoda es removido.", out.width='\\textwidth'}

library(metacoder)
library(taxa)

#clean.obj.st = subset_taxa(physeq, Filo!="Arthropoda")

clean.obj.st = subset_taxa(physeq, Especie != "NA")

phylo2meta <- clean.obj.st

obj <- parse_phyloseq(phylo2meta) # The following taxon IDs do not exist: NA
# tax_data <- data.frame(tax_table(phylo2meta), stringsAsFactors = FALSE)
 #obj <- parse_tax_data(tax_data)
# filter_taxa(obj, taxon_ranks == "Arthropoda", supertaxa = TRUE)

sample_dat <- sample_data(phylo2meta)
sample_dat$sample_id <- rownames(sample_dat)

# Calculamos la abundancia por taxon y no la abundancia por ASV
obj$data$tax_abund <- calc_taxon_abund(obj, "otu_table",
                                       cols = sample_dat$sample_id)

# We can also easily calculate the number of samples that have reads for each taxon:
# obj$data$tax_occ <- calc_n_samples(obj, "tax_abund", groups = sample_dat$Transecto)

set.seed(100) # This makes the plot appear the same each time it is run 

# node_color <- sample(sample_dat$Transecto)[1]

# noquote(paste0('obj$data$tax_occ$',node_color)),

heat_tree(obj, 
          node_label = taxon_names,
          node_size = n_obs,
          node_color = n_obs,# obj$data$tax_occ$A, 
          #node_size_axis_label = "Numero de amplicones ",
          node_color_axis_label = paste0("Presencia de taxones"), # en el crucero ", set),
          # The primary layout algorithm
          layout = "davidson-harel", 
          # The layout algorithm that initializes node locations
          initial_layout = "reingold-tilford")

# detach("package:taxa", unload=TRUE)
# las siguientes lineas son para hacer un subset del grafico
# unique(tax_table(clean.obj)[,2])
# set.seed(1) # Each number will produce a slightly different result for some layouts
# obj %>%
#   #filter_taxa(grepl(pattern = "^[a-zA-Z]+$", taxon_names)) %>% # remove "odd" taxa
#   filter_taxa(taxon_names %in% c("Arthropoda", "Mollusca", "Nematoda"),
#               subtaxa = TRUE) %>% 

png(paste0(path,"/", "track_plot.png"), units="px", width=2400, height=2600, res=400)
plot(track_plot, col=adjustcolor("black", alpha=0.2))
dev.off()

```


```{r Figura 6. bar.phy, fig.align = "center", fig.cap = "Figura 6. Composición de las comunidades a nivel Filo a lo largo de las estaciones. Se presentan los taxones con varianza mayor a  1e-5.", out.width='\\textwidth', fig.width=8}
agglom_rank <- function(physeq, taxrank, filter = 0.01, NArm = FALSE) {
  require(data.table)
  
  ra <- sample_sums(physeq) > 100
  if(ra) {
    physeq <- transform_sample_counts(physeq, function(x) (x / sum (x) ) * 100)
    
    Rank <-tax_glom(physeq, taxrank = taxrank, NArm=NArm)
  } else {
    Rank <-tax_glom(physeq, taxrank = taxrank, NArm=NArm)
  }
  
  #taxaOrder = names(sort(taxa_sums(Rank), decreasing = TRUE))
  
  mdf = psmelt(Rank)
  mdf = data.table(mdf)
  
  mdf[(Abundance <= filter), taxrank[1] := "Others"]
  # mdf[(is.na(taxrank[1])), taxrank[1] := "Others"]
  # mdf = subset(mdf, taxrank != NA)
  
  return(mdf)
}

taxrank <- 'Filo' # Rank a aglomerar
fra <- 0 # Filter RA

caption <- paste0("Se agrupan en la categoria 'Others' las asignaciones 'redundantes' y con RA <= ", fra, " %")

mdf <- agglom_rank(physeq, taxrank, filter = fra)

mdf[(is.na(Filo)), taxrank[1] := "Others"]

library(ggplot2)

colourCount <- length(unique(mdf[,Filo]))
levs <- levels(factor(mdf$Filo))

library(RColorBrewer)

getPalette = colorRampPalette(brewer.pal(colourCount, "Set3"))
fvalues = getPalette(colourCount)

fvalues[which(levs %in% 'Others')] <- '#636363'
                   
theme_set( theme_classic())

p = ggplot(mdf, aes(x = Estación, y = Abundance, fill = Filo)) +
  scale_fill_manual(values = fvalues) +
  coord_flip()
p = p + geom_bar(stat = "identity", position = "stack", color = "black")
p = p + theme(axis.text.x = element_text(angle = -90, hjust = 0), 
              axis.text.y = element_text(size  = 7))

bar <- p + facet_grid(~ Crucero, space = "free", scales = "free") +
  labs(x = 'Estación', y = 'Abundancia Relativa (%)', 
         caption = caption) +
  guides(fill=guide_legend(ncol=2))

ggsave(bar, filename = paste0(path,"/", "Figura-6S-bar.phy.png"))

bar 
```

```{r Figura 7. bar.Class, fig.align = "center", fig.cap = "Figura 7. Composición de las comunidades a nivel Clase a lo largo de las estaciones. Se presentan los taxones con varianza mayor a  1e-5.", out.width='\\textwidth', fig.width=8}

taxrank <- 'Clase' # Rank a aglomerar
fra <- 1 # Filter RA

caption <- paste0("Se agrupan en la categoria 'Others' las asignaciones 'redundantes' y con RA <= ", fra, ' %')

mdf <- agglom_rank(physeq, taxrank[1], filter = fra)

mdf[(is.na(Clase)), taxrank[1] := "Others"]

library(ggplot2)

colourCount <- length(unique(mdf[, Clase]))
levs <- levels(factor(mdf$Clase))

library(RColorBrewer)

getPalette = colorRampPalette(brewer.pal(12, "Set3"))
fvalues = getPalette(colourCount)

fvalues[which(levs %in% 'Others')] <- '#636363'
                   
theme_set( theme_classic())

p = ggplot(mdf, aes(x = Estación, y = Abundance, fill = Clase)) +
  scale_fill_manual(values = fvalues) +
  coord_flip()
p = p + geom_bar(stat = "identity", position = "stack", color = "black")
p = p + theme(axis.text.x = element_text(angle = -90, hjust = 0), 
              axis.text.y = element_text(size  = 7))

bar <- p + facet_grid(~ Crucero, space = "free", scales = "free") +
  labs(x = 'Estación', y = 'Abundancia Relativa (%)', 
         caption = caption) +
  guides(fill=guide_legend(ncol=2))

ggsave(bar, 
       filename = paste0(path,"/", "Figura-6S-bar.Class.png"), 
       width = 10,height = 7)

bar
```

```{r Figura 8. Heatmap.Or, fig.align = "center", fig.cap = "Figura 8. Composición de las comunidades a nivel Orden a lo largo de las estaciones. Se presentan los taxones con varianza mayor a  1e-5.", fig.height = 7, fig.width = 8}

taxrank <- "Orden"

fra <- 0.1 # Filter RA

caption <- paste0("Se presenta el nivel ", taxrank, " con una RA >= ", fra)


Order <-tax_glom(physeq, taxrank = taxrank)
Order <- transform_sample_counts(Order, function(x) (x / sum (x) ) * 100)
# Order <- filter_taxa(Order, function(x) sum(x) >= fra, TRUE)

taxaOrder = names(sort(taxa_sums(Order), decreasing = TRUE))
otu_table(Order)[otu_table(Order) == 0] <- NA

#taxaOrder = rownames(sort(unique(tax_table(Order)[,'Orden']), decreasing=TRUE))
colourCount <- 8 
getPalette = colorRampPalette(brewer.pal(colourCount, "YlGnBu"))
fvalues = getPalette(colourCount)

plot <- NULL

plot <- plot_heatmap(Order, 
             sample.label = "Estación", 
             sample.order = "Transecto",
             taxa.label = "Orden",
             taxa.order = taxaOrder,
             na.value = "#fc4e2a", trans = NULL, 
             low = fvalues[1:4],
             high = fvalues[4:8]) +
        labs(fill = "Abundancia\nRelativa (%)",
             caption = caption) +
        theme(legend.position = "left")

plot <- plot + coord_flip() + theme(axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1), axis.text.y = element_text(size  = 10)) + facet_grid(Crucero ~ ., space = "free", scales = "free")

ggsave(plot, 
       filename = paste0(path,"/", "Figura-8-Heatmap.Or.png"), 
       width = 14,height = 10)

plot
```

```{r Figura 9. Heatmap.Fam, fig.align = "center", fig.cap="Figura 9. Composición de las comunidades a nivel Familia a lo largo de las estaciones. Se presentan los taxones con varianza mayor a  1e-5; respectivamente, se indican el nivel de Filos y Clase en las columnas del panel derecho", fig.width = 8, fig.height = 7}

Family <- phyloseq::filter_taxa(physeq2, function(x) var(x) > 1e-5, TRUE)
Family <-tax_glom(Family, taxrank="Familia")
Family = subset_taxa(Family, Familia!="NA")


taxaOrder = rownames(sort(unique(tax_table(Family)[,'Familia']), decreasing=TRUE))

h <- plot_heatmap(Family, 
                  #"NMDS", "bray", 
             sample.label = "Estación", 
             sample.order = "Transecto",
             taxa.label = "Familia",
             taxa.order = taxaOrder,
             na.value = "white", trans = NULL) +
        scale_fill_gradient2(low = "#FFFFD9", high = "#081D58") + #, limits=c(0,100)) +
        labs(fill = "Abundancia\nRelativa (%)", title = paste0(set, " Crucero"),
             caption = 'Taxones con varianza mayor a  1e-5')

plot <- NULL

plot <- h + facet_grid(Filo+Clase ~ ., 
               scales = "free", space = "free" 
    #                             switch = "y"
              ) + 
  theme(
  strip.text.y = element_text(
                        angle = 0, 
                        size = 5),
  strip.background = element_rect(colour = "black", 
                                  fill = "transparent",
                                  size = 0.1),
  panel.spacing = unit(0.001, "lines")
       ) +
  labs(fill = "Abundancia\nRelativa (%)")


png(paste0(path,"/", "Figura-9-Heatmap.Fam.png"), units="px", width=3000, height=3100, res=400)
plot(plot, col=adjustcolor("black", alpha=0.2))
dev.off()

```

```{r Figura 10. Boxplot species, fig.align = "center", fig.cap = "Especies más abundantes a lo largo de todas las estaciones. Se muestran aquellos taxones que representan al menos 10% de la abundancia total por muestra.", fig.width = 8, fig.height = 7}
library(data.table)
library(ggplot2)
# also try: https://github.com/joey711/phyloseq/issues/494

Level <- length(Ranks)
Rank <- Ranks[Level]

glom <- physeq2 # you can also use clean.obj
# glom <- transform_sample_counts(glom, function(x) (x / sum (x) ) * 100 )
glom <- tax_glom(glom, taxrank = Rank)

# create dataframe from phyloseq object

dat <- data.table(psmelt(glom))

dat.bkp <- dat
# dat <- dat.bkp

# plot(density(dat$Abundance))
# convert Taxa to a character vector from a factor because R
dat$Especie <- as.character(dat$Especie)

size <- 2
# Change name to remainder of rank less than 1%
dat[(Abundance <= size), Especie := "Otros"]


# boxplot
plot <- NULL
max_ab <- round(max(dat$Abundance))

plot <- ggplot(dat[Abundance > 0 & Especie != 'NA'],
      aes(x=reorder(Especie, Abundance, FUN = median),
          y=Abundance)) +
 geom_boxplot() +
 coord_flip() +
 #scale_y_log10() + 
 ylim(0, max_ab) +
 theme_minimal() + 
 facet_wrap(~ Tipo, nrow = 2 ) +
 labs(y = "Abundancia Relativa (%)", x ="Especies", title = paste0("Especies abundantes del crucero ", set),
      caption = paste0("taxones que representan mas del ", size, "% de la abundancia por muestra"))


png(paste0(path,"/", "Figura-10-boxplot.Sp.png"), units="px", width=2700, height=3700, res=400)
plot(plot, col=adjustcolor("black", alpha=0.2))
dev.off()


```

```{r Figura 10S. Bubbleplot, bubbleplot Species, fig.align = "center", fig.cap = "Especies más abundantes a lo largo de todas las estaciones. Se muestran aquellos taxones que representan al menos 10% de la abundancia total por muestra (Se colorean por orden cada una de las especies).", fig.width = 8, fig.height = 7}

library(RColorBrewer)

colourCount = length(unique(dat$Orden)) 
getPalette = colorRampPalette(brewer.pal(12, "Set1")) 

size <- 5
# Change name to remainder of rank less than 1%
dat[(Abundance <= size), Especie := "Otros"]

plot <- NULL
plot <- ggplot(dat[Abundance > 0 & Especie != 'Otros' & Especie != 'NA'], 
       aes(x=Estación, 
           y=Especie, 
           color=Orden)) +
  geom_point(aes(size=Abundance))+ facet_grid(.~Tipo, scales="free_x") +
  # scale_color_manual(values = getPalette(colourCount)) +
  scale_color_brewer(palette = 'Dark2', direction = -1) +
  theme_classic() +
  theme(
        axis.title.x=element_blank(),
        axis.text.x=element_text(angle = 45, hjust = 1)) +
  labs(size = "Abundancia\nRelativa (%)", y = "Especie", title = paste0("Especies abundantes del crucero ", set),
      caption = paste0("taxones que representan mas del ", size, "% de la abundancia por muestra"))

plot <- plot + coord_flip()

png(paste0(path,"/", "Figura-10-bubbleplot.Sp.png"), units="px", width=2500, height=3000, res=400)
plot(plot, col=adjustcolor("black", alpha=0.2))
dev.off()


```

```{r metacoder.ex, eval = FALSE, echo = FALSE}

# Comparing two treatments/groups

obj$data$diff_table <- compare_groups(obj,
                                      dataset = "tax_abund",
                                      cols = sample_dat$sample_id, # What columns of sample data to use
                                      groups = sample_dat$Transecto) # What category each sample is assigned to

print(obj$data$diff_table)
#

set.seed(1)
heat_tree_matrix(obj,
                 dataset = "diff_table",
                 node_size = n_obs, # n_obs is a function that calculates, in this case, the number of OTUs per taxon
                 node_label = taxon_names,
                 node_color = log2_median_ratio, # A column from `obj$data$diff_table`
                 node_color_range = diverging_palette(), # The built-in palette for diverging data
                 node_color_trans = "linear", # The default is scaled by circle area
                 node_color_interval = c(-3, 3), # The range of `log2_median_ratio` to display
                 edge_color_interval = c(-3, 3), # The range of `log2_median_ratio` to display
                 node_size_axis_label = "Number of ASVs",
                 node_color_axis_label = "Log2 ratio median proportions",
                 layout = "davidson-harel", # The primary layout algorithm
                 initial_layout = "reingold-tilford", # The layout algorithm that initializes node locations
                 output_file = "differential_heat_tree.pdf") # Saves the plot as a pdf file
```

## Estimación de los índices de diversidad y presentación gráfica de resultados.

La estimación de los índices de diversidad y la generación de representaciones gráficas de los resultados del análisis bioinformático se realizó en R v3.5.0 utilizando diferentes paquetes especializados en análisis de datos ecológicos y gráficos.

Se realizó una curva de rarefacción para evaluar el esfuerzo de secuenciación por estación (Figura 11). Se observó que en la mayoría de las estaciones el número de amplicones puede incrementar aún más si se dedica un mayor esfuerzo de secuenciación.

```{r funcion rarefaccion}
ggrare2 <- function (physeq_object, step = 10, label = NULL, color = NULL, 
          plot = TRUE, parallel = FALSE, se = TRUE) 
{
  x <- methods::as(phyloseq::otu_table(physeq_object), "matrix")
  if (phyloseq::taxa_are_rows(physeq_object)) {
    x <- t(x)
  }
  tot <- rowSums(x)
  S <- rowSums(x > 0)
  nr <- nrow(x)
  rarefun <- function(i) {
    #cat(paste("rarefying sample", rownames(x)[i]), sep = "\n")
    n <- seq(1, tot[i], by = step)
    if (n[length(n)] != tot[i]) {
      n <- c(n, tot[i])
    }
    y <- vegan::rarefy(x[i, , drop = FALSE], n, se = se)
    if (nrow(y) != 1) {
      rownames(y) <- c(".S", ".se")
      return(data.frame(t(y), Size = n, Sample = rownames(x)[i]))
    }
    else {
      return(data.frame(.S = y[1, ], Size = n, Sample = rownames(x)[i]))
    }
  }
  if (parallel) {
    out <- parallel::mclapply(seq_len(nr), rarefun, mc.preschedule = FALSE)
  }
  else {
    out <- lapply(seq_len(nr), rarefun)
  }
  df <- do.call(rbind, out)
  if (!is.null(phyloseq::sample_data(physeq_object, FALSE))) {
    sdf <- methods::as(phyloseq::sample_data(physeq_object), 
                       "data.frame")
    sdf$Sample <- rownames(sdf)
    data <- merge(df, sdf, by = "Sample")
    labels <- data.frame(x = tot, y = S, Sample = rownames(x))
    labels <- merge(labels, sdf, by = "Sample")
  }
  if (length(color) > 1) {
    data$color <- color
    names(data)[names(data) == "color"] <- deparse(substitute(color))
    color <- deparse(substitute(color))
  }
  if (length(label) > 1) {
    labels$label <- label
    names(labels)[names(labels) == "label"] <- deparse(substitute(label))
    label <- deparse(substitute(label))
  }
  p <- ggplot2::ggplot(data = data, ggplot2::aes_string(x = "Size", 
                                                        y = ".S", group = "Sample", color = color))
  p <- p + ggplot2::labs(x = "Sequence Sample Size", y = "Species Richness")
  if (!is.null(label)) {
    p <- p + ggplot2::geom_text(data = labels, ggplot2::aes_string(x = "x", 
                                                                   y = "y", label = label, color = color), size = 4, 
                                hjust = 0)
  }
  p <- p + ggplot2::geom_line()
  if (se) {
    p <- p + ggplot2::geom_ribbon(ggplot2::aes_string(ymin = ".S - .se", 
                                                      ymax = ".S + .se", color = NULL, fill = color), alpha = 0.2)
  }
  if (plot) {
    plot(p)
  }
  invisible(p)
}
```

```{r Figura 11 Rarefaccion, echo = FALSE, fig.align = "center", fig.cap = "Figura 11. Curva de rarefacción por muestra. Se presenta el número de amplicones a lo largo de las estaciones en relación al número de secuencias.",  out.width='\\textwidth', fig.width = 7, fig.height = 4}
# https://github.com/gauravsk/ranacapa/
# and https://github.com/joey711/phyloseq/issues/143

library(ranacapa)
theme_set(theme_classic())

rr <- physeq
minsample <- min(sample_sums(rr))

rrplot <- ggrare2(rr, step = 100, label = "Estación", 
                 color="Crucero", 
                 se = FALSE, plot = FALSE) 

plot <- NULL
plot <- rrplot +
  xlab("Numero de secuencias") + ylab("Numero de amplicones") + 
    theme(text = element_text(size=12),
        panel.background = element_blank(), legend.position = "none") +
  geom_point(size=0.7) +
  geom_vline(xintercept = min(sample_sums(rr)), linetype = "dashed") +
  scale_color_manual(values=getPalette(length(unique(samples$Crucero))))

png(paste0(path,"/", "Figura-11-rarefaction.png"), units="px", width=3700, height=2500, res=400)
plot(plot, col=adjustcolor("black", alpha=0.2))
dev.off()

```


```{r Figura 12. Div. alfa, fig.align = "center", fig.cap = "Figura 12. Diversidad alfa por estación. Se muestran los índices de diversidad alfa de Shannon e Inverso de Simpson calculados para la comunidad de zooplancton cada estación.", out.width='\\textwidth', fig.width = 7, fig.height = 5}

library(RColorBrewer)

getPalette = colorRampPalette(brewer.pal(9, "Set1"))
alfa <- physeq
n <-length(unique(sample_data(alfa)$Transecto))
alfa <- transform_sample_counts(alfa, function(x) 1E6 * x/sum(x))

prichnes <- plot_richness(alfa, x="Estación", color="Transecto", measures=c("Shannon", "InvSimpson"))
prichnes$layers <- prichnes$layers[-1]

plot <- NULL
plot <- prichnes + scale_color_manual(values=getPalette(n)) + 
    geom_point(size=5, alpha=0.7) +
    #theme(
        #axis.title.x=element_blank(),
        #axis.text.x=element_blank(),
        #axis.ticks.x=element_blank())  +
        ylab("Diversidad alfa") +
        labs(title = paste0(set, " Crucero"))
          
png(paste0(path,"/", "Figura-12-alfa-div.png"), units="px", width=4500, height=2500, res=400)
plot(plot, col=adjustcolor("black", alpha=0.2))
dev.off()

```

La diversidad alfa se obtuvo a través del cálculo de los índices de Shannon e Inverso de Simpson en cada estación (Figura 12). En ambos índices se observa que la mayoría de las estaciones se encuentra en un rango de diversidad definido pero sobresalen (contienen mayor diversidad) las siguientes (tabla 1)

```{r Tabla 1. Índices Diversidad, eval = FALSE, echo = FALSE}
library(phyloseq)

richness <- estimate_richness(physeq, measures = c("Observed", 
                                   "Chao1", "ACE", 
                                   "Fisher", "Shannon", 
                                   "InvSimpson"
                                   ))

rownames(richness) <- sample_data(physeq)$`Estación`

save <- round(richness[order(richness$Shannon, decreasing = TRUE),], digits = 2)

write.table(save, file = paste0(path, "_",set, "_richness.csv"))

knitr::kable(save, caption = 'Tabla 1')

```

La diferencia en composición de la comunidad entre estaciones se evaluó mediante un análisis de coordenadas principales usando una matriz de distancias Jaccard. En la figura 13 se observa que no hay formación de grupos definidos de estaciones indicando comunidades similares.

```{r Figura 13. PCoA, fig.align = "center", fig.cap = "Figura 13. PCoA. Componentes principales (Distancias Jaccard).", fig.width = 7, fig.height = 5}

getPalette = colorRampPalette(brewer.pal(12, "Paired"))
n <-length(unique(sample_data(physeq)$Transecto))

physeq.rr <- transform_sample_counts(physeq, function(x) 1E6 * x/sum(x))
iDist <- phyloseq::distance(physeq.rr, method="jaccard") # Jaccard
iMDS  <- ordinate(rr, "PCoA", distance=iDist) 
# pairs(iMDS$values)
# hist(iMDS$values[, 'Eigenvalues'])
p <- plot_ordination(rr, iMDS, justDF = FALSE,
                     color="Transecto"
                     #label="Estación"
                     #shape="Cruice"
                     ) 
p$layers <- p$layers[-1]

plot <- NULL
plot <- p + geom_text(aes(label = Estación), size = 5, check_overlap = TRUE) + theme(legend.position = "none") +
  scale_color_manual(values=getPalette(n))
# plot + geom_label(aes(label = Estación),  size = 5) + theme(legend.position = "none")
# plot + geom_path(aes(x=Axis.2, y=Axis.1, colour=Transecto), size=0.7, linetype=2)           

png(paste0(path,"/", "Figura-13-PCoA.png"), units="px", width=3000, height=3000, res=400)
plot(plot, col=adjustcolor("black", alpha=0.2))
dev.off()

```

```{r NMDS, eval = FALSE, echo = FALSE}
# Transform data to proportions as appropriate for Bray-Curtis distances
library(RColorBrewer)

getPalette = colorRampPalette(brewer.pal(12, "Paired"))
n <-length(unique(sample_data(physeq)$Transecto))


ps.prop <- transform_sample_counts(physeq, function(x) x/sum(x))
ord.nmds.bray <- ordinate(ps.prop, method="NMDS", distance="bray")

p <- NULL
p <- plot_ordination(ps.prop, ord.nmds.bray,
                     color="Transecto",
                     title="Bray NMDS ordinations"
                     ) 

p$layers <- p$layers[-1]
plot <- NULL
plot <- p + geom_text(aes(label = Estación), size = 5, check_overlap = TRUE) + theme(legend.position = "none") +
  scale_color_manual(values=getPalette(n))
# plot + geom_label(aes(label = Estación),  size = 5) + theme(legend.position = "none") 
# plot + geom_path(aes(x=NMDS1, y=NMDS2, colour=Transecto), size=0.7, linetype=2)
            

png(paste0(path,"/", "Figura-13S-NMDS.png"), units="px", width=3000, height=3000, res=400)
plot(plot, col=adjustcolor("black", alpha=0.2))
dev.off()
    

```

```{r Tree construction, eval=FALSE, warning=FALSE, echo = FALSE, message = FALSE}
#.cran_packages <- c("dplyr")
#.bioc_packages <- c("Biostrings", "DECIPHER", "phangorn")
#sapply(c(.cran_packages, .bioc_packages), require, character.only = TRUE)

require("dplyr")
require("Biostrings")
require("DECIPHER")
require("phangorn")

fasta.file <- list.files(fasta.dir, pattern = fasta.file, full.names = TRUE)

seqs <- readDNAStringSet(fasta.file)
#names(seqs) <- seqs # This propagates to the tip labels of the tree

phylo.df <- as_tibble(phyloseq::psmelt(physeq))
colnames(phylo.df)[1] <- "label"

df <- phylo.df %>% group_by(label) %>% 
  filter (!duplicated(label)) %>% 
  select(label, Sample, Clase, Orden, Familia, Genero, Especie) %>%
  as_tibble()

seqs.subset <- seqs[names(seqs) %in% rownames(tax_table(physeq))]

# subset <- rownames(otu_table(physeq))
# seqs.subset <- seqs[names(seqs) %in% subset]

# Construct phylogenetic tree

alignment <- AlignSeqs(DNAStringSet(seqs.subset), anchor=NA, verbose = FALSE)

# The phangorn R package is then used to construct a phylogenetic tree. 
# follow lines construct a neighbor-joining tree, 
# and then fit a GTR+G+I (Generalized time-reversible with Gamma rate variation) maximum likelihood tree 
# using the neighbor-joining tree as a starting point

phangAlign <- phyDat(as(alignment, "matrix"), type="DNA")
dm <- dist.ml(phangAlign)

treeNJ <- NJ(dm) # Note, tip order != sequence order
fit = pml(treeNJ, data=phangAlign)
fitGTR <- update(fit, k=4, inv=0.2)
fitGTR <- optim.pml(fitGTR, model="GTR", optInv=TRUE, optGamma=TRUE,
        rearrangement = "stochastic", control = pml.control(trace = 0))

detach("package:phangorn", unload=TRUE)

```

```{r Figura 15. GTR+G+I tree, fig.align = "center", fig.cap = "Figura 15. Las secuencias de _Actinoperigy_ fueron alineadas y la filogenia construída por el método Neighbor Joining ajustado con el modelo GTR+G+I. La paleta de colores indica la asociación de los taxones a nivel Familia y la etiqueta de los géneros.", fig.height = 7, eval=FALSE}

tree <- fitGTR$tree

library(ggtree)

x <- as_data_frame(tree)
y <- full_join(x, df, by = 'label')
tre <- NULL
tre <- y %>% tidytree::as.treedata()


library(RColorBrewer)

colourCount = length(unique(df$Especie))
getPalette = colorRampPalette(brewer.pal(9, "Set1"))

ggtree(tre, branch.length='none', layout='slanted', aes(color= Especie, fill=Especie), na.rm = FALSE) +
  theme(legend.position="right") +
  scale_color_manual(values = c(getPalette(colourCount)), 
                     na.value = "grey", 
                     guide = guide_legend(ncol=1)) +
  xlim(0, 30) +
  geom_tiplab(size=4, aes(label=Especie), offset=0.5) +
  geom_nodepoint(alpha=1/4, size=2) + theme(legend.position = "none",
                                            panel.grid = element_blank())

```

## Citas

1. Callahan BJ, McMurdie PJ, Rosen MJ, Han AW, Johnson AJA, Holmes SP (2016). “DADA2: High-resolution sample inference from Illumina amplicon data.” _Nature Methods_, *13*, 581-583.

2. Machida RJ, Leray M, Ho SL, Knowlton N, (2017). Metazoan mitochondrial gene sequence reference datasets for taxonomic assignment of environmental samples. _Nature Scientific Data_, Sci Data. 2017; 4: 170027.

3.  Wang, Q, G. M. Garrity, J. M. Tiedje, and J. R. Cole. (2007). Naïve Bayesian Classifier for Rapid Assignment of rRNA Sequences into the New Bacterial Taxonomy. _Appl Environ Microbiol_. 73(16):5261-7.

4. Callahan BJ, Sankaran K, Fukuyama JA et al. Bioconductor Workflow for Microbiome Data Analysis: from raw reads to community analyses [version 2; referees: 3 approved]. F1000Research 2016, 5:1492


